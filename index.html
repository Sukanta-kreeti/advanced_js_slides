<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h4>Mr. Surendra Singhi</h4>
          <p>CEO/ Founder at Kreeti Technologies</p>
          <p>Arizona State University<br>Master of Science, Computer Science<br>2004-2005</p>
          <p>B.M.S College of Engineering<br>Bachelor of Engineering, Computer Science<br>1999-2003</p>
        </section>

        <section>
          <h4>Functional Programing</h4>
          <p align="left" style="padding-top: 20px;">
            In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.
          </p>
        </section>

        <section>
          <h4>Side effect</h4>
          <p align="left" style="padding-top: 20px;">
            In computer science, a function or expression is said to have a side effect if it modifies some state or has an observable interaction with calling functions or the outside world.
          </p>
          <p align="left" style="padding-top: 20px; font-size: 25px">
            For example, this function has no side effects. Its result depends only on its input arguments, and nothing about the state of the program or its environment changes when it is called:
          </p>
          <pre>
            <code data-trim data-noescape>
              int square(int x) { return x * x; }
            </code>
          </pre>

          <p align="left" style="padding-top: 20px; font-size: 25px">
            In contrast, calling these functions will give you different results depending upon the order in which you call them, because they change something about the state of the computer:
          </p>
          <pre>
            <code data-trim data-noescape>
              int n = 0;
              int next_n() { return n++; }
              void set_n(int newN) { n = newN; }
            </code>
          </pre>
        </section>

        <section>
          <h4>Pure function</h4>

          <p align="left" style="padding-top: 20px; font-size: 25px">
            In computer programming, a function may be considered a pure function if both of the following statements about the function hold:
          </p>

          <ul style="font-size: 25px">
            <li style="padding-bottom: 10px;">
              The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or between different executions of the program, nor can it depend on any external input from I/O devices.
            </li>
            <li>
              Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices.
            </li>
          </ul>

          <pre>
            <code data-trim data-noescape>
              var values = { a: 1 };

              function pureFunction ( a ) {
                var b = 1;
                a = a * b + 2;

                return a;
              }

              var c = pureFunction( values.a );
              // `values.a` has not been modified, it's still 1
            </code>
          </pre>
        </section>
        <section>
          <h4>Higher-order functions</h4>
          <p align="left" style="padding-top: 20px; font-size: 25px">
            Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.
          </p>
          <p align="left" style="padding-top: 20px; font-size: 25px">
            Higher-order functions allow us to abstract over actions, not just values. They come in several forms. For example, you can have functions that create new functions.
          </p>

          <pre>
            <code data-trim data-noescape>
              function greaterThan(n) {
                return function(m) { return m > n; };
              }

              var greaterThan10 = greaterThan(10);
              console.log(greaterThan10(11));
              // → true
            </code>
          </pre>
        </section>
        <section>
          <h4>Higher-order functions</h4>
          <pre>
            <code data-trim data-noescape>
              var items = [
              { name: 'Edward', value: 21 },
              { name: 'Sharpe', value: 37 },
              { name: 'And', value: 45 },
              { name: 'The', value: -12 },
              { name: 'Magnetic' },
              { name: 'Zeros', value: 37 }
              ];

              // sort by value

              items.sort(function (a, b) {
                if (a.value > b.value) {
                  return 1;
                }

                if (a.value < b.value) {
                  return -1;
                }

                return 0;
              });
            </code>
          </pre>
        </section>
        <section>
          <h4>Anonymous function</h4>

          <p align="left" style="padding-top: 20px; font-size: 25px">
            An anonymous function is a function definition that is not bound to an identifier.
          </p>

          <p align="left" style="padding-top: 20px; font-size: 25px">Normal function definition:</p>

          <pre>
            <code data-trim data-noescape>
              function hello() {
                alert('Hello world');
              }

              hello();
            </code>
          </pre>

          <p align="left" style="padding-top: 20px; font-size: 25px">Anonymous function definition:</p>

          <pre>
            <code data-trim data-noescape>
              var anon = function() {
                alert('I am anonymous');
              };

              anon();
            </code>
          </pre>
        </section>
        <section>
          <h5>for...of statement</h5>

          <pre>
            <code data-trim data-noescape>
              for (variable of iterable) { statement }
            </code>
          </pre>

          <p align="left" style="padding-top: 20px; font-size: 25px">
            variable: On each iteration a value of a different property is assigned to variable.<br>
            iterable: Object whose enumerable properties are iterated.
          </p>

          <pre>
            <code data-trim data-noescape>
              let iterable = [10, 20, 30];

              for (let value of iterable) {
                console.log(value);
              }
              // 10
              // 20
              // 30
            </code>
          </pre>
        </section>
        <section>
          <h5>Iterating using map:</h5>
          <p align="left" style="padding-top: 20px; font-size: 20px">
            The map() method creates a new array with the results of calling a provided function on every element in this array.
            map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results
          </p>

          <pre>
            <code data-trim data-noescape>
              var numbers = [1, 4, 9];
              var roots = numbers.map(Math.sqrt);
              // roots is now [1, 2, 3], numbers is still [1, 4, 9]
            </code>
          </pre>

          <pre>
            <code data-trim data-noescape>
              var kvArray = [{key:1, value:10}, {key:2, value:20}, {key:3, value: 30}];

              var reformattedArray = kvArray.map(function(obj){
                var rObj = {};
                rObj[obj.key] = obj.value;
                return rObj;
              });

              // reformattedArray is now [{1:10}, {2:20}, {3:30}],
              // kvArray is still [{key:1, value:10}, {key:2, value:20}, {key:3, value: 30}]
            </code>
          </pre>
        </section>
        <section>
          <h5>reduce() function</h5>

          <p align="left" style="padding-top: 20px; font-size: 25px">
            The reduce() method applies a function against an accumulator and each value of the array (from left-to-right) to reduce it to a single value.
          </p>

          <pre>
            <code data-trim data-noescape>
              [0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, currentIndex, array) {
                return previousValue + currentValue;
              });
            </code>
          </pre>

          <table style="padding-top: 20px; font-size: 15px">
            <thead>
              <tr>
                <th scope="col">&nbsp;</th>
                <th scope="col"><code>previousValue</code></th>
                <th scope="col"><code>currentValue</code></th>
                <th scope="col"><code>currentIndex</code></th>
                <th scope="col"><code>array</code></th>
                <th scope="col">return value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th scope="row">first call</th>
                <td><code>0</code></td>
                <td><code>1</code></td>
                <td><code>1</code></td>
                <td><code>[0, 1, 2, 3, 4]</code></td>
                <td><code>1</code></td>
              </tr>
              <tr>
                <th scope="row">second call</th>
                <td><code>1</code></td>
                <td><code>2</code></td>
                <td><code>2</code></td>
                <td><code>[0, 1, 2, 3, 4]</code></td>
                <td><code>3</code></td>
              </tr>
              <tr>
                <th scope="row">third call</th>
                <td><code>3</code></td>
                <td><code>3</code></td>
                <td><code>3</code></td>
                <td><code>[0, 1, 2, 3, 4]</code></td>
                <td><code>6</code></td>
              </tr>
              <tr>
                <th scope="row">fourth call</th>
                <td><code>6</code></td>
                <td><code>4</code></td>
                <td><code>4</code></td>
                <td><code>[0, 1, 2, 3, 4]</code></td>
                <td><code>10</code></td>
              </tr>
            </tbody>
          </table>
        </section>
        <section>
          <h4>Arrow functions</h4>
          <p align="left" style="padding-top: 20px; font-size: 25px">
            An arrow function expression has a shorter syntax compared to function expressions and lexically binds the this value
          </p>
          <pre>
            <code data-trim data-noescape>
              (param1, param2, …, paramN) => { statements }
              (param1, param2, …, paramN) => expression
              // equivalent to:  => { return expression; }

              // Parentheses are optional when there's only one parameter:
              (singleParam) => { statements }
              singleParam => { statements }

              // A function with no parameters requires parentheses:
              () => { statements }
            </code>
          </pre>
        </section>
        <section>
          <h4>Arrow function</h4>
          <pre>
            <code data-trim data-noescape>
              var numbers = [1, 4, 9];
              var roots = numbers.map(() => Math.sqrt);
              // roots is now [1, 2, 3], numbers is still [1, 4, 9]
            </code>
          </pre>

          <pre>
            <code data-trim data-noescape>
              var kvArray = [{key:1, value:10}, {key:2, value:20}, {key:3, value: 30}];

              var reformattedArray = kvArray.map((obj) => {
                var rObj = {};
                rObj[obj.key] = obj.value;
                return rObj;
              });

              // reformattedArray is now [{1:10}, {2:20}, {3:30}],
              // kvArray is still [{key:1, value:10}, {key:2, value:20}, {key:3, value: 30}]
            </code>
          </pre>
        </section>
        <section>
          <h4>this in JS</h4>
          <h5>Global context</h5>
          <p align="left" style="padding-top: 20px; font-size: 25px">
            In the global execution context (outside of any function), this refers to the global object
          </p>
          <pre>
            <code data-trim data-noescape>
              console.log(this.document === document); // true

              // In web browsers, the window object is also the global object:
              console.log(this === window); // true

              this.a = 37;
              console.log(window.a); // 37
            </code>
          </pre>
        </section>
        <section>
          <h4>Function context</h4>
          <h5>Simple call</h5>
          <p align="left" style="padding-top: 20px; font-size: 25px">
            Inside a function, the value of this depends on how the function is called. In this case, the value of this is not set by the call. Since the code is not in strict mode, the value of this must always be an object so it defaults to the global object.
          </p>
          <pre>
            <code data-trim data-noescape>
              function f1() { return this; }

              f1() === window; // global object
            </code>
          </pre>
        </section>
        <section>
          <h5>Object method</h5>
          <p align="left" style="padding-top: 20px; font-size: 25px">
            When a function is called as a method of an object, its this is set to the object the method is called on.
            In the following example, when o.f() is invoked, inside the function this is bound to the o object.
          </p>
          <pre>
            <code data-trim data-noescape>
              var o = {
                prop: 37,
                f: function() {
                  return this.prop;
                }
              };

              console.log(o.f()); // logs 37
            </code>
          </pre>
        </section>
        <section>
          <h5>As a constructor</h5>
          <p align="left" style="padding-top: 20px; font-size: 25px">
           When a function is used as a constructor (with the new keyword), its this is bound to the new object being constructed.
          </p>
          <pre>
            <code data-trim data-noescape>
              /*
              * Constructors work like this:
              *
              * function MyConstructor() {
              *   // Actual function body code goes here.
              *   // Create properties on |this| as
              *   // desired by assigning to them.  E.g.,
              *   this.fum = "nom";
              *   // et cetera...
              *
              *   // If the function has a return statement that
              *   // returns an object, that object will be the
              *   // result of the |new| expression.  Otherwise,
              *   // the result of the expression is the object
              *   // currently bound to |this|
              *   // (i.e., the common case most usually seen).
              * }
              */

              function C() {
                this.a = 37;
              }

              var o = new C();
              console.log(o.a); // logs 37


              function C2() {
                this.a = 37;
                return { a:38 };
              }

              o = new C2();
              console.log(o.a); // logs 38
            </code>
          </pre>
        </section>
        <section>
          <h5>call and apply</h5>
          <p align="left" style="padding-top: 20px; font-size: 25px">
           Where a function uses the this keyword in its body, its value can be bound to a particular object in the call using the call or apply methods that all functions inherit from Function.prototype.
          </p>
          <pre>
            <code data-trim data-noescape>
              function add(c, d) {
                return this.a + this.b + c + d;
              }

              var o = {a:1, b:3};

              // The first parameter is the object to use as
              // 'this', subsequent parameters are passed as
              // arguments in the function call
              add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16

              // The first parameter is the object to use as
              // 'this', the second is an array whose
              // members are used as the arguments in the function call
              add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34
            </code>
          </pre>
        </section>
        <section>
          <h5>bind method</h5>
          <p align="left" style="padding-top: 20px; font-size: 25px">
           ECMAScript 5 introduced Function.prototype.bind. Calling f.bind(someObject) creates a new function with the same body and scope as f, but where this occurs in the original function, in the new function it is permanently bound to the first argument of bind, regardless of how the function is being used.
          </p>
          <pre>
            <code data-trim data-noescape>
              function f() {
                return this.a;
              }

              var g = f.bind({ a: "azerty" });
              console.log(g()); // azerty

              var o = { a:37, f:f, g:g };
              console.log(o.f(), o.g()); // 37, azerty
            </code>
          </pre>
        </section>
        <section>
          <h5>Prototype based programing using JS</h5>
          <p align="left" style="padding-top: 20px; font-size: 25px">
           JavaScript is an object-based language based on prototypes, rather than being class-based. Because of this different basis, it can be less apparent how JavaScript allows you to create hierarchies of objects and to have inheritance of properties and their values.
          </p>
          <pre>
            <code data-trim data-noescape>
              function Employee() {
                this.name = "";
                this.dept = "general";
              }

              function Manager() {
                Employee.call(this);
                this.reports = [];
              }

              Manager.prototype = Object.create(Employee.prototype);

              function WorkerBee() {
                Employee.call(this);
                this.projects = [];
              }

              WorkerBee.prototype = Object.create(Employee.prototype);

              function SalesPerson() {
                WorkerBee.call(this);
                this.dept = "sales";
                this.quota = 100;
              }

              SalesPerson.prototype = Object.create(WorkerBee.prototype);

              function Engineer() {
                WorkerBee.call(this);
                this.dept = "engineering";
                this.machine = "";
              }

              Engineer.prototype = Object.create(WorkerBee.prototype);
            </code>
          </pre>
        </section>
        <section>
          <h4>Comparison of class-based and prototype-based object systems</h4>
          <table  align="left" style="padding-top: 20px; font-size: 20px">
            <thead>
              <tr>
                <th scope="col">Class-based</th>
                <th scope="col">Prototype-based</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Class and instance are distinct entities.</td>
                <td>All objects can inherit from another object.</td>
              </tr>
              <tr>
                <td>Define a class with a class definition; instantiate a class with constructor methods.</td>
                <td>Define and create a set of objects with constructor functions.</td>
              </tr>
              <tr>
                <td>Create a single object with the <code>new</code> operator.</td>
                <td>Same.</td>
              </tr>
              <tr>
                <td>Construct an object hierarchy by using class definitions to define subclasses of existing classes.</td>
                <td>Construct an object hierarchy by assigning an object as the prototype associated with a constructor function.</td>
              </tr>
              <tr>
                <td>Inherit properties by following the class chain.</td>
                <td>Inherit properties by following the prototype chain.</td>
              </tr>
              <tr>
                <td>Class definition specifies <em>all</em> properties of all instances of a class. Cannot add properties dynamically at run time.</td>
                <td>Constructor function or prototype specifies an <em>initial set</em> of properties. Can add or remove properties dynamically to individual objects or to the entire set of objects.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section>

        </section>
        </section>
        <section>
        </section>
        <section>
        </section>
        <section>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
